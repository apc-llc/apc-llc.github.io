DAY ONE:
9:30-11:00 Introduction to GPU computing
= GPU architecture basics
= Introduction to the concept of warps, threads and blocks
= The memory hierarchy
11:00-12:30 Introduction to OpenACC
= OpenACC programming model, execution model, memory model
= The advantages of OpenACC in comparison with CUDA C/Fortran
= OpenACC directive syntax
= Main directives: parallel, region, kernels, loop, data and combinations; examples
12:30-13:00 Lunch Break
13:00-14:45 Hands-on: Implement a vector addition function with OpenACC:
= Add OpenACC directives into existing serial implementation, build and execute the program (C directives).
= Compare the complexity and performance with the given CUDA implementation.
14:45-15:00 Coffee Break
15:00-17:00 Hands-on: Jacobi iterative solver with OpenACC.

DAY TWO:
09:30-11:00 Advanced programming with OpenACC
= Other directives: host_data, cache, update, wait, declare; examples
= Runtime library routines
= Environment and conditional compilation
= Constraints
= Interoperability with GPU-enabled math libraries
11:00-12:30 Porting applications for NVIDIA GPUs with OpenACC
= Example of using OpenACC in real applications: WRF numerical model
= Exercises with profiling and performance analysis
12:30-13.00 Lunch Break
13:00-14:45 Hands-on: A set of examples for step-by-step optimization study with OpenACC
14:45-15:00 Coffee Break
15:00-17:00 Hands-on (continued)

